1. Spring Framework

Konzepte (Container, Komponenten, Kontexte, Injection, Auto-Configuration)
Technologien (Remoting, Data Access, Configuration, Integration)

--
Spring Boot ist eines der beliebtesten Frameworks für die Entwicklung von Java-Anwendungen. Sein Kern basiert auf zwei grundlegenden Konzepten: Dependency Injection (DI) und Inversion of Control (IoC) .

Bean
- A bean is an instance of a class managed by the Spring container

Container
- Part of the core of the Spring Framework
- Responsible for managing all the beans
- Performs dependency injection

Annotation Bean vs Component
Bean is a method level annotation
Component, Controller, Repository, etc. are class level annotations

The spring application context represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans.
Ein IoC-Container (Inversion of Control-Container) ist eine Komponente eines Software-Frameworks, die die Erstellung und den Lebenszyklus von Objekten (oft als Beans bezeichnet) übernimmt und ihre Abhängigkeiten über Dependency Injection (DI) verwaltet.

AutoConfiguration
In Spring musste viel manuell konfiguriert werden. z.B. musste man eine Klasse mit @PropertySource(value={"classpath:application.properties"} erzeugen und die Properties dort definieren.
Mit SpringBoot wurde eine Default-Konfiguration definiert. Sprint Boot schaut, solange nichts anderes definiert, automatisch ob es eine Datei application.properties gibt.
z.B. auch automatisch welche ports verwendet werden


2. Persistence

Entities, Entity Manager, Persistence Context
O/R-Mapping, Entity Relationships
Abfragen mit JPQL
Spring Data JPA Repositories
Testcontainers

Es gibt verschiedene Wege/Konzepte um der Persistence Layer in Spring zu implementieren
- Hibernate
- JPA
- Spring Data

Welches Problem löst Hibernate?
Datentransfer/Mapping zwischenDB-Tabelle "USER" und (Java-)Objekt USER (Klasse)
@Entity in Klasse (Dependency = hibernate-core)
Falls Klasse und Tabellenname unterschiedlich sind, wird @Table(name = "USERS") verwendet (Tabelle = USERS, class = USER)
Hibernate muss wissen was der Primary-Key ist. Dies wird in der Klasse bei der Variable (z.B. für private Loing userId) mit folgenden Annotations gemacht: 
@Id
@GeneratedValue(strategy = GenrationType.IDENTITY)

Falls Column-Name und Objekt-Variable nicht gleich heissen (Column-Name in DB = BIRTH_DATE, in Java Klasse = birthDate):
@Colunm(name = "birth_day")
private LocalDate birthDate;

Hibernate braucht einen empty Constructor um Daten zu fetchen (abrufen):
public User() {
}
Hibernate hat eine eigene Query-Language "HQL". Dies orientiert sich nach Klassenhierarchie. Pure SQL works on tabels.
Man würde dann schreiben:
session.createQuery("select u.birthDate from User u", User.class); (SQL wäre Tabellen orientiert: select u.BIRTH_DATE from USERS)


3. Spring Core

Spring Beans, Scopes, Dependency Injection
Transaction Management
Aspect-oriented Programming
Messaging mit JMS und AMQP


4. Spring Web

HTML-Rendering mit Thymeleaf
Implementierung von REST-Services und -Clients
Error Handling, Message Converter, Filters, Bean Validation
Testing und Dokumentation